# Part of 'ljfit' package
"""
Useful functions for the ljfit package.
"""

#############################################

from __future__ import annotations

import sys
from pathlib import Path
from typing import List, Optional, Union

import matplotlib.pyplot as plt
import pandas as pd
from lmfit import Parameters

from .. import __version__

# define constants
EH2KCAL = 627.503  # kcal/mol
ANGSTROM2BOHR = 1.8897259885789  # conversion factor from angstrom to bohr


def get_file_list(path: str, regex: str) -> List[Path]:
    """Get a list of files in a directory.

    Parameters
    ----------
    path : str
        path to the directory where the files are located
    regex : str
        regular expression to filter the files

    Returns
    -------
    list
        list of posix paths to the files
    """
    filelist = []
    for file in sorted(Path(path).rglob(regex)):
        filelist.append(file)

    if len(filelist) == 0:
        sys.exit("No '*data' files found.")

    return filelist


def read_xyz(file: str | Path) -> pd.DataFrame:
    """Reads xyz file into pandas DataFrame

    Parameters
    ----------
    file : str | Path
        Path to xyz file

    Returns
    -------
    pd.DataFrame
        Output DataFrame with columns ['atom', 'x', 'y', 'z']
    """

    # read file into DataFrame
    xyz = pd.read_csv(
        file, delim_whitespace=True, skiprows=2, names=["atom", "x", "y", "z"]
    )

    return xyz


def write_xyz(coords: pd.DataFrame, file: str | Path) -> None:
    """Writes DataFrame to xyz file

    Parameters
    ----------
    coords : pd.DataFrame
        Input DataFrame with columns ['atom', 'x', 'y', 'z']
    file : str | Path
        Path to output xyz file
    """

    with open(file, "w") as f:
        # write number of atoms
        f.write(f"{len(coords)}\n")
        # write comment line
        f.write("Generated by custom code of Tom Froembgen\n")
        # write coordinates
        coords.to_csv(f, sep=" ", header=False, index=False)


def combine_xyz(
    xyzlist: list[pd.DataFrame], output: Optional[Union[str, Path]]
) -> pd.DataFrame:
    """Combines multiple xyz files into one DataFrame

    Parameters
    ----------
    xyzlist : list[pd.DataFrame]
        List of xyz files as DataFrames
    output : str | Path, optional
        Path to output xyz file

    Returns
    -------
    pd.DataFrame
        Combined DataFrame with columns ['atom', 'x', 'y', 'z']
    """

    # combine all DataFrames in list
    combined = pd.concat(xyzlist, ignore_index=True)

    # write output file if path is given
    if output:
        write_xyz(combined, output)

    return combined


def print_lj_params(df: pd.DataFrame, i: int) -> List[str]:
    """Write the lj parameters to the console in common units.
    That is, convert the parameters from atomic units to kcal/mol and Angstrom.

    Parameters
    ----------
    df : pd.DataFrame
        DataFrame containing the lj parameters in a.u., with columns ['atom_pair', 'epsilon', 'sigma', 'Delta_eps', 'Delta_sig']
    i : int
        Iteration number
    """
    # make a copy of the DataFrame
    dc = df.copy()
    dc["epsilon"] *= EH2KCAL
    dc["sigma"] /= ANGSTROM2BOHR

    if i == -1:
        return [
            "\nFinal LJ parameters",
            "-------------------",
            "kcal/mol / Angstrom\n",
            dc.to_string(index=False, float_format="{:.5f}".format),
        ]
    else:
        return [
            f"\nIteration {i}",
            "------------",
            dc.to_string(index=False, float_format="{:.5f}".format),
        ]


def params_to_df(params: Parameters) -> pd.DataFrame:
    """Converts lmfit.Parameters with LJ parameters to pd.DataFrame

    Parameters
    ----------
    params : Parameters
        Input lmfit.Parameters

    Returns
    -------
    pd.DataFrame
        Output DataFrame with columns ['atom_pair', 'epsilon', 'sigma']
    """

    l_params = []
    for key in params.keys():
        if key.endswith("_0") and key.startswith("epsilon"):
            atom_pair = key.split("_")[1] + "_" + key.split("_")[2]
            epsilon = params[f"epsilon_{atom_pair}_0"].value
            sigma = params[f"sigma_{atom_pair}_0"].value
            l_params.append([atom_pair, epsilon, sigma])

    df_params = pd.DataFrame(l_params, columns=["atom_pair", "epsilon", "sigma"])

    return df_params


def custom_print(string: str | List[str], level: int, print_level: int) -> None:
    """Custom print function with different verbosity levels

    Parameters
    ----------
    string : str | list[str]
        String or list of strings to be printed
    level : int
        Level of the string
    print_level : int
        Level of verbosity
    """
    if print_level >= level:
        if isinstance(string, list):
            for s in string:
                print(s)
        else:
            print(string)


def write_params_to_csv(
    df: pd.DataFrame, i: int, outdir: str | Path, fit_nonpol: bool
) -> None:
    """Writes the parameters to a csv file

    Parameters
    ----------
    df : pd.DataFrame
        DataFrame containing the lj parameters in a.u., with columns ['atom_pair', 'epsilon', 'sigma']
    i : int
        Iteration number
    outdir : str | Path
        Output directory
    fit_nonpol : bool
        Whether to fit the LJ parameters for a non-polarisable force field
    """
    # make a copy of the DataFrame
    dc = df.copy()
    dc["epsilon"] *= EH2KCAL
    dc["sigma"] /= ANGSTROM2BOHR

    # generate directory if it does not exist
    Path(outdir).mkdir(parents=True, exist_ok=True)
    # non-polarisable force field
    if fit_nonpol:
        fstr = "nonpol_"
    else:
        fstr = ""
    # specify output path
    if i == -1:
        outpath = Path(outdir) / f"lj_params_{fstr}final.csv"
    else:
        outpath = Path(outdir) / f"lj_params_{fstr}{i:02d}.csv"
    # remove file if it exists already
    if outpath.exists():
        outpath.unlink()
    # write DataFrame to csv
    dc.to_csv(outpath, index=False, float_format="%.5f")
    print(f"\nParameters written to {outpath}")
